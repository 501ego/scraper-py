import asyncio
from dateutil import parser
import discord
from app.services.database import get_urls_by_source, store_product_info, info_collection
from app.services.scraper import ParisScraper, FalabellaScraper, ProductInfo
from app.utils.price_parser import parse_price
from app.config import PRICE_FIELDS, PARIS_LABELS, FALABELLA_LABELS, service_name, SOURCES
from app.services.logger import get_logger

logger = get_logger(service_name)


def compare_product_prices(url: str, new_info: ProductInfo, label_mapping: dict) -> None:
    """Compares product prices for a URL and logs the differences."""
    stored = info_collection.find_one({"url": url})
    if not stored:
        logger.warning("No record found for URL: %s", url)
        return
    for field in PRICE_FIELDS:
        field_label = label_mapping.get(field, field)
        new_price = parse_price(getattr(new_info, field))
        stored_price = parse_price(stored.get(field_label))
        if new_price is None or stored_price is None:
            continue
        if new_price > stored_price:
            logger.info("For URL %s, %s increased from %s to %s",
                        url, field_label, stored_price, new_price)
        elif new_price < stored_price:
            logger.info("For URL %s, %s decreased from %s to %s",
                        url, field_label, stored_price, new_price)
        else:
            logger.info("For URL %s, %s remains unchanged at %s",
                        url, field_label, new_price)


def format_comparison_details(url: str, new_info: ProductInfo, label_mapping: dict) -> str:
    """Formats product information and price comparisons into a detailed markdown string."""
    try:
        ts = parser.parse(new_info.timestamp)
        formatted_ts = ts.strftime("%d/%m/%Y %H:%M:%S")
    except Exception:
        formatted_ts = new_info.timestamp

    if all(getattr(new_info, field) is None for field in PRICE_FIELDS):
        return ""

    info_section = (
        f"**{label_mapping.get('price1', 'Price1')}:** {getattr(new_info, 'price1')}\n"
        f"**{label_mapping.get('price2', 'Price2')}:** {getattr(new_info, 'price2')}\n"
        f"**{label_mapping.get('price3', 'Price3')}:** {getattr(new_info, 'price3')}\n"
        f"**{label_mapping.get('timestamp', 'Timestamp')}:** {formatted_ts}\n\n"
    )
    changes = ""
    stored = info_collection.find_one({"url": url})
    if stored:
        for field in PRICE_FIELDS:
            field_label = label_mapping.get(field, field)
            new_price = parse_price(getattr(new_info, field))
            stored_price = parse_price(stored.get(field_label))
            if new_price is None or stored_price is None:
                continue
            if new_price > stored_price:
                changes += f"- **{field_label}** increased from {stored_price} to {new_price}\n"
            elif new_price < stored_price:
                changes += f"- **{field_label}** decreased from {stored_price} to {new_price}\n"
    if not changes:
        changes = "**No price changes detected.**"
    return info_section + changes


async def create_embed_for_url(source: str, url: str, scraper, label_mapping: dict, bot: discord.Client = None) -> discord.Embed:
    """
    Creates a Discord embed for a given URL.
    Awaits the asynchronous get_product_info method to get a ProductInfo object.
    """
    try:
        info = await scraper.get_product_info(url)
    except Exception as e:
        logger.error("Error getting product info for %s: %s", url, e)
        return None

    compare_product_prices(url, info, label_mapping)
    store_product_info(source, url, info, label_mapping)
    details = format_comparison_details(url, info, label_mapping)
    if not details:
        return None
    title = f"{source} - {info.name}" if info.name else f"{source} - Unknown Product"
    embed = discord.Embed(title=title, description=details,
                          url=url, color=0xffa500)
    if bot is not None:
        embed.set_footer(
            text=f"Generated by {bot.user.name}", icon_url=bot.user.display_avatar.url)
    return embed


async def get_comparison_embeds(bot: discord.Client = None) -> list:
    """Asynchronously builds and returns a list of discord.Embed objects with product comparisons."""
    embeds = []
    for source in SOURCES:
        if source.lower() == "paris":
            scraper = ParisScraper()
            label_mapping = PARIS_LABELS
        elif source.lower() == "falabella":
            scraper = FalabellaScraper()
            label_mapping = FALABELLA_LABELS
        else:
            continue
        urls = get_urls_by_source(source)
        for url in urls:
            embed = await create_embed_for_url(source, url, scraper, label_mapping, bot)
            if embed is not None:
                embeds.append(embed)
    return embeds
